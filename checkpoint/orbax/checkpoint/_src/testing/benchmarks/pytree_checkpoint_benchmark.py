# Copyright 2025 The Orbax Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Benchmarks for orbax.checkpoint.PyTreeCheckpointHandler."""

from collections.abc import Sequence
import contextlib
import dataclasses
import functools
from typing import Any
from unittest import mock

from absl import logging
import jax
from orbax.checkpoint import checkpoint_utils
from orbax.checkpoint._src.checkpointers import async_checkpointer
from orbax.checkpoint._src.checkpointers import checkpointer as sync_checkpointer
from orbax.checkpoint._src.handlers import pytree_checkpoint_handler
from orbax.checkpoint._src.multihost import multihost
from orbax.checkpoint._src.testing.benchmarks.core import core as benchmarks_core
from orbax.checkpoint._src.testing.benchmarks.core import metric as metric_lib


@contextlib.contextmanager
def _profile(metrics, operation_name, tracemalloc_enabled):
  with contextlib.ExitStack() as stack:
    stack.enter_context(metrics.time(operation_name))
    stack.enter_context(metrics.process_rss(operation_name))
    if tracemalloc_enabled:
      stack.enter_context(metrics.tracemalloc(operation_name))
    yield


# ==============================================================================
# 1. Define the Options Dataclass for this specific benchmark
# ==============================================================================
@dataclasses.dataclass(frozen=True)
class PyTreeCheckpointOptions(benchmarks_core.BenchmarkOptions):
  """Configuration options for benchmarks targeting PyTreeCheckpointHandler.

  Each attribute can be a single value or a list of values to create
  a parameter sweep.

  Attributes:
    use_ocdbt: Whether to use OCPDBT for checkpointing.
    use_zarr3: Whether to use Zarr3 for checkpointing.
  """

  use_ocdbt: bool | Sequence[bool] = True
  use_zarr3: bool | Sequence[bool] = False
  async_checkpointer: bool | Sequence[bool] = True
  tracemalloc_enabled: bool | Sequence[bool] = False


# ==============================================================================
# 2. Implement the Benchmark Generator
# ==============================================================================
@benchmarks_core.benchmark_options(PyTreeCheckpointOptions)
class PyTreeCheckpointBenchmark(benchmarks_core.BenchmarksGenerator):
  """A concrete generator for `orbax.checkpoint.PyTreeCheckpointHandler`.

  This class provides the specific test logic for benchmarking the
  PyTreeCheckpointHandler with various configurations.
  """

  def _clear_pytree(self, pytree: Any) -> Any:
    """Clears the pytree to free up memory."""
    return jax.tree.map(
        lambda x: x.delete() if isinstance(x, jax.Array) else None, pytree
    )

  def test_fn(
      self, context: benchmarks_core.TestContext
  ) -> benchmarks_core.TestResult:
    """The core test logic for a single save/restore cycle.

    This function is called for each combination of options generated by the
    framework. It uses the `context.options` to configure the handler
    dynamically for each run.

    Args:
      context: The test context containing the pytree, path, and options.

    Returns:
      The test result containing the metrics.
    """
    metrics = metric_lib.Metrics()
    pytree = context.pytree
    save_path = context.path / "pytree"
    options = context.options
    assert isinstance(options, PyTreeCheckpointOptions)


    handler = pytree_checkpoint_handler.PyTreeCheckpointHandler(
        use_ocdbt=options.use_ocdbt,
        use_zarr3=options.use_zarr3,
    )

    if options.async_checkpointer:
      checkpointer = async_checkpointer.AsyncCheckpointer(handler)
    else:
      checkpointer = sync_checkpointer.Checkpointer(handler)

    with _profile(metrics, "save", options.tracemalloc_enabled):
      checkpointer.save(
          save_path, args=pytree_checkpoint_handler.PyTreeSaveArgs(pytree)
      )

    if options.async_checkpointer:
      with _profile(
          metrics, "wait_until_finished", options.tracemalloc_enabled
      ):
        assert hasattr(checkpointer, "wait_until_finished")
        checkpointer.wait_until_finished()

    context.pytree = self._clear_pytree(context.pytree)

    with _profile(metrics, "restore", options.tracemalloc_enabled):
      checkpointer.restore(
          save_path,
          args=pytree_checkpoint_handler.PyTreeRestoreArgs(
              item=pytree,
              restore_args=checkpoint_utils.construct_restore_args(pytree),
          ),
      )

    checkpointer.close()
    return benchmarks_core.TestResult(metrics=metrics)
