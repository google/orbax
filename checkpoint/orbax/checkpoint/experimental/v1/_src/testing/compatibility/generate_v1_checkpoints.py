# Copyright 2026 The Orbax Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generates V1 checkpoints for compatibility testing.

The checkpoints generated by this script are checked into the repository
statically. While our library's logic changes over time, user-held checkpoints
do not. Checking these in allows us to test the interaction between evolving
code and "frozen" static artifacts, ensuring long-term backward compatibility
that runtime generation (which only tests current library behavior) cannot
guarantee.
"""

import json
import os
from typing import Any

from absl import app
from absl import flags
from etils import epath
import jax.numpy as jnp
from orbax.checkpoint import test_utils
import orbax.checkpoint.experimental.v1 as ocp
from orbax.checkpoint.experimental.v1._src.handlers import registration


FLAGS = flags.FLAGS


def _get_base_dir():
  if 'BUILD_WORKING_DIRECTORY' in os.environ:
    return os.path.join(
        os.environ['BUILD_WORKING_DIRECTORY'],
        'orbax/checkpoint/experimental/v1/_src/testing/compatibility/checkpoints',
    )
  return os.path.join(
      os.path.dirname(__file__),
      'checkpoints',
  )


_BASE_DIR = flags.DEFINE_string(
    'base_dir',
    _get_base_dir(),
    'Base directory to save checkpoints.',
)
_OVERWRITE = flags.DEFINE_bool(
    'overwrite',
    False,
    'Overwrite existing checkpoints.',
)


def create_pytree() -> dict[str, Any]:
  return {
      'a': jnp.array([0, 1, 2, 3, 4, 5, 6, 7], dtype=jnp.int32),
      'b': {'c': jnp.array([1, 2, 3], dtype=jnp.int32)},
  }


def create_json_object() -> dict[str, Any]:
  return {'metadata': 'json_data'}


def generate_v1_checkpoint(path: epath.Path,) -> None:
  """Saves a direct checkpoint using save_checkpointables."""
  checkpointables = {
      'state': create_pytree(),
      'metadata': create_json_object(),
  }
  if _OVERWRITE.value:
    path.rmtree(missing_ok=True)

  registry = registration.local_registry()
  registry.add(ocp.handlers.PyTreeHandler, 'state')
  registry.add(ocp.handlers.JsonHandler, 'metadata')
  with ocp.Context(
      checkpointables_options=ocp.options.CheckpointablesOptions(
          registry=registry
      )
  ):
    ocp.save_checkpointables(path, checkpointables)
    (path / 'descriptor').rmtree()  # GOOGLE_INTERNAL


def modify_item_handlers(
    path: epath.Path, checkpointable_name: str, handler_name: str
) -> None:
  """Modifies the item handlers in _CHECKPOINT_METADATA."""
  metadata_path = path / '_CHECKPOINT_METADATA'
  with open(metadata_path, 'r') as f:
    data = json.load(f)
  data['item_handlers'][checkpointable_name] = handler_name
  with open(metadata_path, 'w') as f:
    json.dump(data, f)


def delete_checkpoint_metadata_field(
    path: epath.Path, field_to_remove: str
) -> None:
  """Deletes a field from _CHECKPOINT_METADATA."""
  metadata_path = path / '_CHECKPOINT_METADATA'
  with open(metadata_path, 'r') as f:
    data = json.load(f)
  del data[field_to_remove]
  with open(metadata_path, 'w') as f:
    json.dump(data, f)


def v1_metadata_present_composite_has_pytree() -> None:
  """Checkpoint metadata present, composite, and has pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'has_checkpoint_metadata'
      / 'composite_checkpoint'
      / 'has_pytree_metadata'
  )
  generate_v1_checkpoint(path)


def v1_metadata_present_composite_missing_pytree() -> None:
  """Checkpoint metadata present, composite, and missing pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'has_checkpoint_metadata'
      / 'composite_checkpoint'
      / 'missing_pytree_metadata'
  )
  generate_v1_checkpoint(path)
  (path / 'state' / '_METADATA').unlink()


def v1_metadata_present_unregistered_has_pytree() -> None:
  """Checkpoint metadata present, unregistered, and has pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'has_checkpoint_metadata'
      / 'unregistered_checkpoint'
      / 'has_pytree_metadata'
  )
  generate_v1_checkpoint(path)
  modify_item_handlers(path, 'state', 'UnregisteredHandler')
  modify_item_handlers(path, 'metadata', 'UnregisteredHandler')


def v1_metadata_present_unregistered_missing_pytree() -> None:
  """Checkpoint metadata present, unregistered, and missing pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'has_checkpoint_metadata'
      / 'unregistered_checkpoint'
      / 'missing_pytree_metadata'
  )
  generate_v1_checkpoint(path)
  (path / 'state' / '_METADATA').unlink()

  modify_item_handlers(path, 'state', 'UnregisteredHandler')
  modify_item_handlers(path, 'metadata', 'UnregisteredHandler')


def v1_missing_metadata_composite_has_pytree() -> None:
  """Checkpoint metadata missing, composite, and has pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'missing_checkpoint_metadata'
      / 'composite_checkpoint'
      / 'has_pytree_metadata'
  )
  generate_v1_checkpoint(path)
  (path / '_CHECKPOINT_METADATA').unlink()


def v1_missing_metadata_composite_missing_pytree() -> None:
  """Checkpoint metadata missing, composite, and missing pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'missing_checkpoint_metadata'
      / 'composite_checkpoint'
      / 'missing_pytree_metadata'
  )
  generate_v1_checkpoint(path)
  (path / '_CHECKPOINT_METADATA').unlink()
  (path / 'state' / '_METADATA').unlink()


def v1_missing_non_critical_field_in_checkpoint_metadata(
    field_to_remove: str,
) -> None:
  """Saves V1 checkpoint and removes a non-critical field from metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'non_critical_alterations'
      / f'missing_{field_to_remove}_metadata'
  )
  generate_v1_checkpoint(path)
  delete_checkpoint_metadata_field(path, field_to_remove)


def v1_missing_critical_field_in_checkpoint_metadata(
    field_to_remove: str,
) -> None:
  """Saves V1 checkpoint and removes a critical field from metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'critical_alterations'
      / f'missing_{field_to_remove}_metadata'
  )
  generate_v1_checkpoint(path)
  delete_checkpoint_metadata_field(path, field_to_remove)


def v1_missing_non_critical_pytree_data_files(
    file_to_remove: str,
) -> None:
  """Saves a checkpointables checkpoint and removes a non-critical data file."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'non_critical_alterations'
      / f'missing_pytree_data_file_{file_to_remove}'
  )
  generate_v1_checkpoint(path)
  (path / 'state' / file_to_remove).unlink()


def v1_missing_critical_pytree_data_files(
    file_to_remove: str,
) -> None:
  """Saves a checkpointables checkpoint and removes a critical data file."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'critical_alterations'
      / f'missing_pytree_data_file_{file_to_remove}'
  )
  generate_v1_checkpoint(path)
  (path / 'state' / file_to_remove).unlink()


def v1_missing_non_critical_pytree_data_dir(
    dir_to_remove: str,
) -> None:
  """Saves a checkpointables checkpoint and removes a non-critical directory."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'non_critical_alterations'
      / f'missing_pytree_data_dir_{dir_to_remove}'
  )
  generate_v1_checkpoint(path)
  (path / 'state' / dir_to_remove).rmtree()


def v1_missing_critical_pytree_data_dir(
    dir_to_remove: str,
) -> None:
  """Saves a checkpointables checkpoint and removes a critical directory."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'critical_alterations'
      / f'missing_pytree_data_dir_{dir_to_remove}'
  )
  generate_v1_checkpoint(path)
  (path / 'state' / dir_to_remove).rmtree()


def v1_dummy_checkpointable_present() -> None:
  """Saves a checkpointables checkpoint and adds a dummy checkpointable."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'general_alteration'
      / 'dummy_checkpointable_present'
  )
  generate_v1_checkpoint(path)
  (path / 'dummy').mkdir()
  (path / 'dummy' / '_METADATA').write_text('dummy')


def v1_delete_checkpointable() -> None:
  """Saves a checkpointables checkpoint and adds a deleted checkpointable."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v1_checkpoints'
      / 'general_alteration'
      / 'deleted_checkpointable_present'
  )
  generate_v1_checkpoint(path)
  (path / 'state').rmtree()


def main(argv):
  del argv
  epath.Path(_BASE_DIR.value).mkdir(parents=True, exist_ok=True)

  test_utils.set_tensorstore_driver_for_test()

  print('Generating V1 Checkpoints...')
  # Three categories we'll generate against:
  # 1. Is Checkpoint Metadata present?
  # - Yes, No
  # 2. Item_handler type
  # - dict(composite saved with save_checkpointables/pytree), unregistered
  # 3. Is Pytree? (Pytree Metadata present in checkpointable dir?)
  # - Yes, No

  # The directory structure will follow the categories above:
  # base_dir /
  # 'v1_checkpoints' /
  # <Ckpt_Metadata_Present/Missing> /
  # <Item_Handler_Type> /
  # <Is_Pytree_Yes/No> /

  # Combinations
  # V1,Yes,dict,yes
  v1_metadata_present_composite_has_pytree()
  # V1,Yes,dict,no
  v1_metadata_present_composite_missing_pytree()
  # V1,Yes,unregistered,yes
  v1_metadata_present_unregistered_has_pytree()
  # V1,Yes,unregistered,no
  v1_metadata_present_unregistered_missing_pytree()
  # V1,No,dict(composite checkpoint),yes
  v1_missing_metadata_composite_has_pytree()
  # V1,No,dict(composite checkpoint),no
  v1_missing_metadata_composite_missing_pytree()
  # V1,No,unregistered,yes
  # N/A
  # V1,No,unregistered,no
  # N/A

  # Additional Corruptions
  # Will generate composite and direct pytree checkpoints for metadata
  # alterations.
  # The directory structure will be:
  # base_dir /
  # 'v1_checkpoints' /
  # <'non_critical_alterations'/'critical_alterations'> /
  # <Alteration_Type> /

  # Missing Fields
  fields_to_remove = [
      'item_handlers',
      'metrics',
      'performance_metrics',
      'init_timestamp_nsecs',
      'commit_timestamp_nsecs',
      'custom_metadata',
  ]
  for field in fields_to_remove:
    v1_missing_non_critical_field_in_checkpoint_metadata(field)

  critical_files_to_remove = ['_sharding', 'manifest.ocdbt']
  for file_to_remove in critical_files_to_remove:
    v1_missing_critical_pytree_data_files(file_to_remove)

  critical_dirs_to_remove = ['ocdbt.process_0']
  for dir_to_remove in critical_dirs_to_remove:
    v1_missing_critical_pytree_data_dir(dir_to_remove)

  non_critical_dirs_to_remove = ['array_metadatas', 'd']
  for dir_to_remove in non_critical_dirs_to_remove:
    v1_missing_non_critical_pytree_data_dir(dir_to_remove)

  # Adding cases for dummy and deleted checkpointables within checkpoint, due to
  # user modification of checkpoint.
  # The directory structure will follow the categories above:
  # base_dir /
  # 'v1_checkpoints' /
  # 'general_alteration' /
  # <Alteration_Type> /
  v1_dummy_checkpointable_present()
  v1_delete_checkpointable()

  print(f'V1 Checkpoints generated at {_BASE_DIR.value}')


if __name__ == '__main__':
  app.run(main)
