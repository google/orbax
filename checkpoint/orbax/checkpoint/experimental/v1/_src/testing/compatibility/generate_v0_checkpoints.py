# Copyright 2026 The Orbax Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generates V0 checkpoints for compatibility testing.

The checkpoints generated by this script are checked into the repository
statically. While our library's logic changes over time, user-held checkpoints
do not. Checking these in allows us to test the interaction between evolving
code and "frozen" static artifacts, ensuring long-term backward compatibility
that runtime generation (which only tests current library behavior) cannot
guarantee.
"""

import json
import os
from typing import Any

from absl import app
from absl import flags
from etils import epath
import jax.numpy as jnp
from orbax.checkpoint import args
from orbax.checkpoint import test_utils
from orbax.checkpoint._src.checkpointers import checkpointer as v0_checkpointer
from orbax.checkpoint._src.checkpointers import standard_checkpointer
from orbax.checkpoint._src.handlers import composite_checkpoint_handler

FLAGS = flags.FLAGS


def _get_base_dir():
  if 'BUILD_WORKING_DIRECTORY' in os.environ:
    return os.path.join(
        os.environ['BUILD_WORKING_DIRECTORY'],
        'orbax/checkpoint/experimental/v1/_src/testing/compatibility/checkpoints',
    )
  return os.path.join(
      os.path.dirname(__file__),
      'checkpoints',
  )


_BASE_DIR = flags.DEFINE_string(
    'base_dir',
    _get_base_dir(),
    'Base directory to save checkpoints.',
)
_OVERWRITE = flags.DEFINE_bool(
    'overwrite',
    False,
    'Overwrite existing checkpoints.',
)


def create_pytree() -> dict[str, Any]:
  return {
      'a': jnp.array([0, 1, 2, 3, 4, 5, 6, 7], dtype=jnp.int32),
      'b': {'c': jnp.array([1, 2, 3], dtype=jnp.int32)},
  }


def create_json_object() -> dict[str, Any]:
  return {'metadata': 'json_data'}


def _standard_checkpointer_save_pytree(path: epath.Path) -> None:
  """Saves a direct checkpoint using StandardCheckpointer for pytree."""
  pytree = create_pytree()
  if _OVERWRITE.value:
    path.rmtree(missing_ok=True)
  with standard_checkpointer.StandardCheckpointer() as checkpointer:
    checkpointer.save(path, pytree)


def _checkpointer_save_composite_mixed(path: epath.Path) -> None:
  """Saves a composite checkpoint using Checkpointer + CompositeHandler."""
  json_object = create_json_object()
  pytree = create_pytree()
  checkpoint_args = args.Composite(**{
      'state': args.PyTreeSave(pytree),  # Represents pytree checkpointable.
      'metadata': args.JsonSave(json_object),
  })
  if _OVERWRITE.value:
    path.rmtree(missing_ok=True)
  with v0_checkpointer.Checkpointer(
      composite_checkpoint_handler.CompositeCheckpointHandler()
  ) as checkpointer:
    checkpointer.save(path, checkpoint_args)


def generate_v0_checkpoint(
    path: epath.Path,
    is_direct: bool = False,
) -> None:
  """Generates a V0 checkpoint with the given save function."""
  if is_direct:
    _standard_checkpointer_save_pytree(path)
    (path / 'descriptor').rmtree()  # GOOGLE_INTERNAL
  else:
    _checkpointer_save_composite_mixed(path)
    (path / 'state' / 'descriptor').rmtree()  # GOOGLE_INTERNAL


def modify_item_handlers(
    path: epath.Path, checkpointable_name: str, handler_name: str
) -> None:
  """Modifies the item handlers in _CHECKPOINT_METADATA."""
  metadata_path = path / '_CHECKPOINT_METADATA'
  with open(metadata_path, 'r') as f:
    data = json.load(f)
  data['item_handlers'][checkpointable_name] = handler_name
  with open(metadata_path, 'w') as f:
    json.dump(data, f)


def delete_checkpoint_metadata_field(
    path: epath.Path, field_to_remove: str
) -> None:
  """Deletes a field from _CHECKPOINT_METADATA."""
  metadata_path = path / '_CHECKPOINT_METADATA'
  with open(metadata_path, 'r') as f:
    data = json.load(f)
  del data[field_to_remove]
  with open(metadata_path, 'w') as f:
    json.dump(data, f)


def v0_metadata_present_composite_has_pytree() -> None:
  """Checkpoint metadata present, composite, and has pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'has_checkpoint_metadata'
      / 'composite_checkpoint'
      / 'has_pytree_metadata'
  )
  generate_v0_checkpoint(path)


def v0_metadata_present_composite_missing_pytree() -> None:
  """Checkpoint metadata present, composite, and missing pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'has_checkpoint_metadata'
      / 'composite_checkpoint'
      / 'missing_pytree_metadata'
  )
  generate_v0_checkpoint(path)
  (path / 'state' / '_METADATA').unlink()


def v0_metadata_present_direct_has_pytree() -> None:
  """Checkpoint metadata present, direct, and has pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'has_checkpoint_metadata'
      / 'direct_checkpoint'
      / 'has_pytree_metadata'
  )
  generate_v0_checkpoint(path, is_direct=True)


def v0_metadata_present_direct_missing_pytree() -> None:
  """Checkpoint metadata present, direct, and missing pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'has_checkpoint_metadata'
      / 'direct_checkpoint'
      / 'missing_pytree_metadata'
  )
  generate_v0_checkpoint(path, is_direct=True)
  (path / '_METADATA').unlink()


def v0_metadata_present_unregistered_has_pytree() -> None:
  """Checkpoint metadata present, unregistered, has pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'has_checkpoint_metadata'
      / 'unregistered_checkpoint'
      / 'has_pytree_metadata'
  )
  generate_v0_checkpoint(path)
  modify_item_handlers(path, 'state', 'UnregisteredHandler')
  modify_item_handlers(path, 'metadata', 'UnregisteredHandler')


def v0_metadata_present_unregistered_missing_pytree() -> None:
  """Checkpoint metadata present, unregistered, missing pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'has_checkpoint_metadata'
      / 'unregistered_checkpoint'
      / 'missing_pytree_metadata'
  )
  generate_v0_checkpoint(path)
  (path / 'state' / '_METADATA').unlink()
  modify_item_handlers(path, 'state', 'UnregisteredHandler')
  modify_item_handlers(path, 'metadata', 'UnregisteredHandler')


def v0_missing_metadata_composite_has_pytree() -> None:
  """Checkpoint metadata missing, composite, and has pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'missing_checkpoint_metadata'
      / 'composite_checkpoint'
      / 'has_pytree_metadata'
  )
  generate_v0_checkpoint(path)
  (path / '_CHECKPOINT_METADATA').unlink()


def v0_missing_metadata_composite_missing_pytree() -> None:
  """Checkpoint metadata missing, composite, and missing pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'missing_checkpoint_metadata'
      / 'composite_checkpoint'
      / 'missing_pytree_metadata'
  )
  generate_v0_checkpoint(path)
  (path / '_CHECKPOINT_METADATA').unlink()
  (path / 'state' / '_METADATA').unlink()


def v0_missing_metadata_direct_has_pytree() -> None:
  """Checkpoint metadata missing, direct, and has pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'missing_checkpoint_metadata'
      / 'direct_checkpoint'
      / 'has_pytree_metadata'
  )
  generate_v0_checkpoint(path, is_direct=True)
  (path / '_CHECKPOINT_METADATA').unlink()


def v0_missing_metadata_direct_missing_pytree() -> None:
  """Checkpoint metadata missing, direct, and missing pytree metadata."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'missing_checkpoint_metadata'
      / 'direct_checkpoint'
      / 'missing_pytree_metadata'
  )
  generate_v0_checkpoint(path, is_direct=True)
  (path / '_CHECKPOINT_METADATA').unlink()
  (path / '_METADATA').unlink()


def v0_composite_missing_non_critical_field_in_checkpoint_metadata(
    field_to_remove: str,
) -> None:
  """Saves V0 checkpoint and removes a field from _CHECKPOINT_METADATA."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'non_critical_alterations'
      / 'composite_checkpoint_metadata_alterations'
      / f'missing_{field_to_remove}_metadata'
  )
  generate_v0_checkpoint(path)
  delete_checkpoint_metadata_field(path, field_to_remove)


def v0_composite_missing_critical_field_in_checkpoint_metadata(
    field_to_remove: str,
) -> None:
  """Saves V0 checkpoint and removes a field from _CHECKPOINT_METADATA."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'critical_alterations'
      / 'composite_checkpoint_metadata_alterations'
      / f'missing_{field_to_remove}_metadata'
  )
  generate_v0_checkpoint(path, is_direct=True)
  delete_checkpoint_metadata_field(path, field_to_remove)


def v0_composite_missing_non_critical_pytree_data_files(
    file_to_remove: str,
) -> None:
  """Saves a checkpointables checkpoint and removes data files."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'non_critical_alterations'
      / 'composite_checkpoint_metadata_alterations'
      / f'missing_pytree_data_file_{file_to_remove}'
  )
  generate_v0_checkpoint(path)
  (path / 'state' / file_to_remove).unlink()


def v0_composite_missing_critical_pytree_data_files(
    file_to_remove: str,
) -> None:
  """Saves a checkpointables checkpoint and removes data files."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'critical_alterations'
      / 'composite_checkpoint_metadata_alterations'
      / f'missing_pytree_data_file_{file_to_remove}'
  )
  generate_v0_checkpoint(path, is_direct=True)
  (path / file_to_remove).unlink()


def v0_composite_missing_non_critical_pytree_data_dir(
    dir_to_remove: str,
) -> None:
  """Saves a checkpointables checkpoint and removes process directory."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'non_critical_alterations'
      / 'composite_checkpoint_metadata_alterations'
      / f'missing_pytree_data_dir_{dir_to_remove}'
  )
  generate_v0_checkpoint(path)
  (path / 'state' / dir_to_remove).rmtree()


def v0_composite_missing_critical_pytree_data_dir(
    dir_to_remove: str,
) -> None:
  """Saves a checkpointables checkpoint and removes process directory."""
  path = epath.Path(
      epath.Path(_BASE_DIR.value)
      / 'v0_checkpoints'
      / 'critical_alterations'
      / 'composite_checkpoint_metadata_alterations'
      / f'missing_pytree_data_dir_{dir_to_remove}'
  )
  generate_v0_checkpoint(path, is_direct=True)
  (path / dir_to_remove).rmtree()


def main(argv):
  del argv
  epath.Path(_BASE_DIR.value).mkdir(parents=True, exist_ok=True)

  test_utils.set_tensorstore_driver_for_test()

  print('Generating V0 Checkpoints...')
  # Three categories we'll generate against:
  # 1. Is Checkpoint Metadata present?
  # - Yes, No
  # 2. Item_handler type (save method)
  # - dict(composite), str(direct_pytree checkpoint), unregistered (invalid)
  # 3. Is Pytree? (Pytree Metadata present in checkpointable dir?)
  # - Yes, No

  # The directory structure will follow the categories above:
  # base_dir /
  # 'v0_checkpoints' /
  # <Ckpt_Metadata_Present/Missing> /
  # <Item_Handler_Type> /
  # <Is_Pytree_Yes/No> /
  # Optional_Data_Alteration

  # Combinations
  # V0,Yes,dict,yes
  v0_metadata_present_composite_has_pytree()
  # V0,Yes,dict,no
  v0_metadata_present_composite_missing_pytree()
  # V0,Yes,string,yes
  v0_metadata_present_direct_has_pytree()
  # V0,Yes,string,no
  v0_metadata_present_direct_missing_pytree()
  # V0,Yes,unregistered,yes
  v0_metadata_present_unregistered_has_pytree()
  # V0,Yes,unregistered,no
  v0_metadata_present_unregistered_missing_pytree()
  # V0,No,dict(composite checkpoint),yes
  v0_missing_metadata_composite_has_pytree()
  # V0,No,dict(composite checkpoint),no
  v0_missing_metadata_composite_missing_pytree()
  # V0,No,string(direct pytree checkpoint),yes
  v0_missing_metadata_direct_has_pytree()
  # V0,No,string(direct pytree checkpoint),no
  v0_missing_metadata_direct_missing_pytree()
  # V0,No,unregistered,yes
  # N/A
  # V0,No,unregistered,no
  # N/A

  # Additional Corruptions
  # Will generate composite and direct pytree checkpoints for metadata
  # alterations.
  # The directory structure will be:
  # base_dir /
  # 'v0_checkpoints' /
  # <'critical_alterations'/'non_critical_alterations'> /
  # 'composite_checkpoint_metadata_alterations' /
  # <Alteration_Type> /

  # Missing Fields
  fields_to_remove = [
      'item_handlers',
      'metrics',
      'performance_metrics',
      'init_timestamp_nsecs',
      'commit_timestamp_nsecs',
      'custom_metadata',
  ]
  for field in fields_to_remove:
    v0_composite_missing_non_critical_field_in_checkpoint_metadata(field)

  critical_files_to_remove = ['_sharding', 'manifest.ocdbt']
  for file_to_remove in critical_files_to_remove:
    v0_composite_missing_critical_pytree_data_files(file_to_remove)

  critical_dirs_to_remove = ['ocdbt.process_0']
  for dir_to_remove in critical_dirs_to_remove:
    v0_composite_missing_critical_pytree_data_dir(dir_to_remove)

  non_critical_dirs_to_remove = ['array_metadatas', 'd']
  for dir_to_remove in non_critical_dirs_to_remove:
    v0_composite_missing_non_critical_pytree_data_dir(dir_to_remove)

  print(f'V0 Checkpoints generated at {_BASE_DIR.value}')


if __name__ == '__main__':
  app.run(main)
