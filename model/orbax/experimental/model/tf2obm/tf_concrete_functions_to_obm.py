# Copyright 2025 The Orbax Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Converts TF concrete functions to OBM functions (allowing TF resources)."""

from collections.abc import Mapping, Sequence
import os
from typing import Any, Callable, Dict, NamedTuple, Tuple

from jax import tree_util as jax_tree_util
from orbax.experimental.model import core as obm
from orbax.experimental.model.tf2obm import tf_concrete_function_handle_pb2
from orbax.experimental.model.tf2obm import utils
import tensorflow as tf


TF_CONCRETE_FUNCTION_HANDLE_MIME_TYPE = (
    'application/protobuf;'
    ' type=orbax_model_tf_concrete_function_handle.TfConcreteFunctionHandle'
)
TF_CONCRETE_FUNCTION_HANDLE_VERSION = '0.0.1'

# Default sub-dir name for the TF SavedModel (dir) generated by Orbax
# Model.
OBM_TF_SAVED_MODEL_SUB_DIR = 'tf_saved_model/'

TF_SAVED_MODEL_SUPPLEMENTAL_NAME = 'tensorflow_saved_model'

_OUTPUT_NAME_PREFIX = 'output'


def is_pair(tree: utils.TfSignature) -> bool:
  return isinstance(tree, Sequence) and len(tree) == 2


def is_args_kwargs_pattern(tree: utils.TfSignature) -> bool:
  return (
      is_pair(tree)
      and isinstance(tree[0], Sequence)
      and isinstance(tree[1], dict)
  )


def tf_concrete_function_name_to_obm_function(
    name: str,
    *,
    input_signature: utils.TfSignature | None = None,
    output_signature: utils.TfSignature | None = None,
    fn: tf.types.experimental.ConcreteFunction | None = None,
) -> obm.SerializableFunction:
  """Converts a TensorFlow (TF) concrete function name (with input/output signatures) to an Orbax Model (OBM) function.

  The OBM function is essentially a name pointing into a TF SavedModel where the
  concrete function is actually stored.

  Only one of `fn` and the `(input_signature, output_signature)` pair should be
  provided.

  Args:
    name: a name used in `save_tf_concrete_functions` to identify a concrete
      function.
    input_signature: the input signature of the concrete function.
    output_signature: the output signature of the concrete function.
    fn: the concrete function itself.

  Returns:
    An OBM function.
  """
  if fn is not None:
    if input_signature is not None:
      raise ValueError(
          'Both `fn` and `input_signature` are provided. Please provide only '
          'one of them.'
      )
    if output_signature is not None:
      raise ValueError(
          'Both `fn` and `output_signature` are provided. Please provide only '
          'one of them.'
      )
    input_signature = fn.structured_input_signature
    output_signature = get_output_signature(fn)

  input_names, _, _ = _flat_input_signature(fn)
  output_names = _output_names(fn)
  unstructured_data = obm.manifest_pb2.UnstructuredData(
      inlined_bytes=tf_concrete_function_handle_pb2.TfConcreteFunctionHandle(
          fn_name=name,
          input_names=list(input_names),
          output_names=list(output_names),
      ).SerializeToString(),
      mime_type=TF_CONCRETE_FUNCTION_HANDLE_MIME_TYPE,
      version=TF_CONCRETE_FUNCTION_HANDLE_VERSION,
  )
  return obm.SerializableFunction(
      body=obm.UnstructuredDataWithExtName(
          proto=unstructured_data,
          ext_name='pb',
      ),
      input_signature=utils.tf_signature_to_obm_spec(input_signature),
      output_signature=utils.tf_signature_to_obm_spec(output_signature),
  )


SAVED_MODEL_MIME_TYPE = 'application/x.tensorflow-saved-model'
SAVED_MODEL_VERSION = '1.0'


def tf_saved_model_as_obm_supplemental(subdir: str) -> obm.UnstructuredData:
  """An Orbax Model global supplemental pointing to a TF SavedModel (path).

  Args:
    subdir: the path to the TF SavedModel dir. This can be a path relative to
      the Orbax Model dir, such as 'tf_saved_model/', or an absolute path.

  Returns:
    An `obm.UnstructuredData` which can be used as an Orbax Model global
    supplemental.
  """
  return obm.manifest_pb2.UnstructuredData(
      file_system_location=obm.manifest_pb2.FileSystemLocation(
          string_path=subdir
      ),
      mime_type=SAVED_MODEL_MIME_TYPE,
      version=SAVED_MODEL_VERSION,
  )


_StrDict = Dict[str, Any]


def _make_dict_only_signature(
    names: Sequence[str], leaves: Sequence[tf.TensorSpec]
) -> _StrDict:
  """Creates a dict-only signature from names and leaves.

  Args:
    names: A sequence of names for the leaves.
    leaves: A sequence of tensor specs.

  Returns:
    A dict-only signature where keys are names and values are tensor specs.
  """
  # The TensorSpec values in `leaves` may have their `name` attribute
  # set. Some SavedModel loaders (e.g. TFRT) may use this `name`
  # instead of the key in the returned dict to construct the input signature. We
  # clear the `name` attribute to avoid that.
  return {
      k: tf.TensorSpec(
          shape=v.shape,
          dtype=v.dtype,
          name=None,
      )
      for k, v in zip(names, leaves)
  }


def _tree_to_dict(
    tree: utils.TfSignature | None,
    names: Sequence[str] | None,
) -> _StrDict | None:
  """Converts a TF signature tree to a dictionary if names are provided.

  If `names` is None or `tree` is None, returns None. If `names` is provided,
  `tree` is flattened and a dictionary is created by mapping names to leaves.

  Args:
    tree: The TF signature tree.
    names: An optional sequence of names for leaves.

  Returns:
    A dictionary mapping names to leaves, or None.
  """
  if not names or tree is None:
    return None
  flat = jax_tree_util.tree_leaves(tree)
  return dict(zip(names, flat))


def _dict_to_tree(
    d: _StrDict | None,
    names: Sequence[str] | None,
    tree_def: jax_tree_util.PyTreeDef,
) -> utils.TfSignature | None:
  """Converts a dictionary to a TF signature tree if names are provided.

  If `names` is None, `d` is returned unchanged. If `names` is provided,
  leaves are extracted from `d` in the order of `names` and unflattened into a
  tree using `tree_def`.

  Args:
    d: A dictionary mapping names to leaves.
    names: An optional sequence of names for leaves.
    tree_def: The PyTreeDef for unflattening.

  Returns:
    A TF signature tree.
  """
  if not names or not d:
    return None
  flat = tuple(d[name] for name in names)
  return jax_tree_util.tree_unflatten(tree_def, flat)


def _to_args_kwargs_pattern(
    tree: utils.TfSignature,
) -> Tuple[Sequence[Any], Dict[str, Any]]:
  """Converts a TF signature tree to the '(args, kwargs)' pattern.

  Args:
    tree: a TF signature tree.

  Returns:
    A tuple `(args, kwargs)`, where `args` is a sequence of positional
    arguments, and `kwargs` is a dict of keyword arguments.

  Raises:
    ValueError: if the tree cannot be converted to the '(args, kwargs)' pattern.
  """
  if is_args_kwargs_pattern(tree):
    return tree[0], tree[1]
  elif isinstance(tree, Sequence):
    return tree, {}
  elif isinstance(tree, dict):
    return (), tree
  else:
    raise ValueError(
        f"Can`t convert this tree to the '(args, kwargs)' pattern: {tree}"
    )


# The flattened form of a signature: a named tuple of (names, leaves, treedef).
class SignatureFlat(NamedTuple):
  """The flattened form of a signature.

  Attributes:
    names: A sequence of names for the leaves.
    leaves: A sequence of tensor specs.
    tree_def: The PyTreeDef for unflattening.
  """

  names: Sequence[str]
  leaves: Sequence[tf.TensorSpec]
  tree_def: jax_tree_util.PyTreeDef


def _flat_input_signature(
    fn: tf.types.experimental.ConcreteFunction,
) -> SignatureFlat:
  """Returns the flattened input signature of the given function."""
  leaves, tree_def = jax_tree_util.tree_flatten(fn.structured_input_signature)
  # The argument names in SavedModel's SignatureDef may not match the names in
  # the input signature due to internal name mangling, hence we're looking
  # it up in the FunctionDef.
  input_names = [arg.name for arg in fn.function_def.signature.input_arg]
  if len(input_names) < len(leaves):
    # There could be more arguments in the FunctionDef than in the input
    # signature, because it also contains the captured inputs appended
    # to the flattened list of the input arguments.
    raise ValueError(
        f'The number of input arguments in FunctionDef ({len(input_names)}) is'
        ' smaller than the number of leaves in the flattened input signature'
        f' ({len(leaves)})'
    )
  return SignatureFlat(input_names[: len(leaves)], leaves, tree_def)


def _output_name_for_key(key: Any) -> str:
  if isinstance(key, jax_tree_util.SequenceKey):
    return f'{_OUTPUT_NAME_PREFIX}_{key.idx}'
  elif isinstance(key, jax_tree_util.DictKey):
    # The order is stable as guaranteed by `jax.tree.flatten`.
    return f'{key.key}'
  elif isinstance(key, jax_tree_util.GetAttrKey):
    return f'{key.name}'
  raise ValueError(f'Invalid output key type: {key}')


def _output_name(path: Sequence[Any]) -> str:
  """Returns the output name based on its path in the output signature."""
  if not path:
    # Scalar return value (single tensor).
    return f'{_OUTPUT_NAME_PREFIX}_0'

  # Multiple levels of nesting is normally not suppported for
  # TF concrete function outputs. However, we already
  # support the case of nested sturctures in Orbax TF export,
  # so we will explicitly support nested structures here.
  return '.'.join(_output_name_for_key(k) for k in path)


def _output_names(
    fn: tf.types.experimental.ConcreteFunction,
) -> Sequence[str]:
  """Returns the flattened output signature of the given function."""
  leaves_with_path = jax_tree_util.tree_leaves_with_path(
      fn.structured_outputs
  )
  if not leaves_with_path:
    return []
  paths, _ = zip(*leaves_with_path)
  return [_output_name(path) for path in paths]


def get_output_signature(
    fn: tf.types.experimental.ConcreteFunction,
) -> utils.TfSignature:
  """Returns the output signature of the TF function.

  Tensor names in the output signature match the output names of the TF function
  in the TF SavedModel.

  Args:
    fn: A concrete TF function.
  """
  # output_names_iter = iter(list(_output_names(fn)))

  return jax_tree_util.tree_map(
      lambda t: tf.TensorSpec(
          shape=t.shape, dtype=t.dtype
      ),
      fn.structured_outputs,
  )


def to_keyword_only_fn(
    f: tf.types.experimental.ConcreteFunction,
) -> tf.types.experimental.ConcreteFunction:
  """Wraps a function into one whose inputs and outputs are keyword-only.

  Args:
    f: a TF concrete function.

  Returns:
    The wrapped function (also a TF concrete function).
  """
  input_names, input_leaves, input_def = _flat_input_signature(f)
  output_names = _output_names(f)

  if input_names is None and output_names is None:
    return f

  new_input_signature = _make_dict_only_signature(input_names, input_leaves)
  # Note that `new_input_signature`, `input_names` or `output_names`
  # may still be None here.

  @tf.function(
      autograph=False,
  )
  def new_f(**input_dict):
    args, kwargs = _to_args_kwargs_pattern(
        _dict_to_tree(
            input_dict,
            input_names,
            input_def,
        )
    )
    output = f(*args, **kwargs)
    new_output = _tree_to_dict(
        output,
        output_names,
    )
    return new_output

  return new_f.get_concrete_function(
      **new_input_signature,
  )


def save_tf_concrete_functions(
    path: str,
    concrete_functions: Mapping[str, tf.types.experimental.ConcreteFunction],
    trackable_resources: Any = None,
) -> None:
  """Saves TensorFlow (TF) concrete functions with names to a TF SavedModel.

  The TF SavedModel will have enough information to let one retrieve (and call)
  the concrete functions by their names.

  Args:
    path: the absolute path to save the TF SavedModel.
    concrete_functions: a mapping from names to concrete functions.
    trackable_resources: a nested structure (i.e. PyTree) of
      `tf.saved_model.experimental.TrackableResource`s that are used in
      `concrete_functions`. All TF resources the concrete functions use
      (directly or indirectly) must be present in this structure. Otherwise, an
      "untracked resource" error will be raised. If tf.Module is passed, it will
      be used to create the saved model.
  """
  # We are using saved_model.save(signatures=...)
  # (i.e. serving_signatures) to save concrete functions, but
  # serving_signatures only supports functions with keyword-only
  # arguments and outputs (where all arguments and outputs must be
  # tensors), so we need to wrap our concrete function into such a
  # conforming form, and save the information gap separately (in
  # tf_concrete_function_name_to_obm_function).
  concrete_functions = {
      k: to_keyword_only_fn(v) for k, v in concrete_functions.items()
  }

  tf_module = tf.Module()
  if isinstance(trackable_resources, tf.Module):
    tf_module = trackable_resources
  else:
    tf_module.resources = trackable_resources

  tf.saved_model.save(tf_module, path, signatures=concrete_functions)


def create_supplemental_info_closure(
    concrete_functions: Mapping[str, tf.types.experimental.ConcreteFunction],
    trackable_resources: Any = None,
) -> Callable[[str], Mapping[str, obm.GlobalSupplemental]]:
  """Returns a closure that saves TF concrete functions as supplemental data."""

  def save_supplemental_info(
      path: str,
  ) -> Mapping[str, obm.GlobalSupplemental]:
    save_tf_concrete_functions(
        os.path.join(path, OBM_TF_SAVED_MODEL_SUB_DIR),
        concrete_functions,
        trackable_resources,
    )
    tf_global_supplemental = tf_saved_model_as_obm_supplemental(
        OBM_TF_SAVED_MODEL_SUB_DIR
    )
    return {
        TF_SAVED_MODEL_SUPPLEMENTAL_NAME: obm.GlobalSupplemental(
            tf_global_supplemental, None
        )
    }

  return save_supplemental_info
