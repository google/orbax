# Copyright 2025 The Orbax Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Converts TF concrete functions to OBM functions (allowing TF resources)."""

from collections.abc import Mapping, Sequence
import os
from typing import Any, Callable, Dict, NamedTuple, Tuple

from jax import tree_util as jax_tree_util
import numpy as np
from orbax.experimental.model import core as obm
from orbax.experimental.model.tf2obm import tf_concrete_function_handle_pb2
import tensorflow as tf


TF_CONCRETE_FUNCTION_HANDLE_MIME_TYPE = (
    'application/protobuf;'
    ' type=orbax_model_tf_concrete_function_handle.TfConcreteFunctionHandle'
)
TF_CONCRETE_FUNCTION_HANDLE_VERSION = '0.0.1'

# Default sub-dir name for the TF SavedModel (dir) generated by Orbax
# Model.
OBM_TF_SAVED_MODEL_SUB_DIR = 'tf_saved_model/'

TF_SAVED_MODEL_SUPPLEMENTAL_NAME = 'tensorflow_saved_model'

_OUTPUT_NAME_PREFIX = 'output'


TfSignature = obm.Tree[Any]
_StrDict = Dict[str, Any]


def _is_args_kwargs_pattern(tree: TfSignature) -> bool:
  return (
      isinstance(tree, Sequence)
      and len(tree) == 2
      and isinstance(tree[0], Sequence)
      and isinstance(tree[1], dict)
  )


def tf_dtype_to_obm(t: tf.DType) -> obm.ShloDType:
  """Converts a TensorFlow dtype to an OBM ShloDType.

  Args:
    t: The TensorFlow dtype to convert.

  Returns:
    The corresponding OBM ShloDType.

  Raises:
    ValueError: If the TensorFlow dtype cannot be converted to an OBM ShloDType.
  """
  if t == tf.string:
    return obm.ShloDType.str
  # need special handling for bfloat16 since numpy doesn't have a bfloat16
  # dtype.
  if t == tf.bfloat16:
    return obm.ShloDType.bf16
  if t in (tf.resource, tf.variant):
    raise ValueError(f"Can't convert TF dtype {t} to OBM.")
  np_dtype = t.as_numpy_dtype()
  try:
    np_dtype = np.dtype(np_dtype)
  except Exception as err:
    raise ValueError(
        f'Failed to create a numpy.dtype object from {np_dtype} of type '
        f'{type(np_dtype)} . The original TF dtype was {t} of type {type(t)} .'
    ) from err
  return obm.np_dtype_to_shlo_dtype(np_dtype)


def tf_tensor_spec_to_obm(spec: Any) -> obm.ShloTensorSpec:
  # ConcreteFunction.structured_outputs returns `SymbolicTensor`s, not
  # `TensorSpec`s, so we need to also check for `SymbolicTensor`.
  if not (isinstance(spec, tf.TensorSpec) or tf.is_symbolic_tensor(spec)):
    raise ValueError(
        f'Expected a tf.TensorSpec or a SymbolicTensor, got {spec} of type'
        f' {type(spec)}'
    )
  return obm.ShloTensorSpec(
      shape=spec.shape, dtype=tf_dtype_to_obm(spec.dtype), name=spec.name
  )


def tf_signature_to_obm_spec(
    tree: TfSignature,
) -> obm.Tree[obm.ShloTensorSpec]:
  try:
    return jax_tree_util.tree_map(tf_tensor_spec_to_obm, tree)
  except Exception as err:
    raise ValueError(
        f'Failed to convert TF signature {tree} of type {type(tree)} to OBM.'
    ) from err


def tf_function_to_obm(
    fn_name: str,
    fn: tf.types.experimental.ConcreteFunction,
) -> obm.SerializableFunction:
  """Converts a TensorFlow (TF) concrete function name (with input/output signatures) to an Orbax Model (OBM) function.

  The OBM function is a name pointing into a TF SavedModel where the
  concrete function is stored.

  Args:
    fn_name: The name of the function to be saved in the OBM manifest.
    fn: A TF concrete function.

  Returns:
    An OBM function.
  """
  input_signature = fn.structured_input_signature
  output_signature = get_output_signature(fn)

  input_names, _, _ = _flat_input_signature(fn)
  output_names = _output_names(fn)
  unstructured_data = obm.manifest_pb2.UnstructuredData(
      inlined_bytes=tf_concrete_function_handle_pb2.TfConcreteFunctionHandle(
          fn_name=fn_name,
          input_names=list(input_names),
          output_names=list(output_names),
      ).SerializeToString(),
      mime_type=TF_CONCRETE_FUNCTION_HANDLE_MIME_TYPE,
      version=TF_CONCRETE_FUNCTION_HANDLE_VERSION,
  )
  return obm.SerializableFunction(
      body=obm.UnstructuredDataWithExtName(
          proto=unstructured_data,
          ext_name='pb',
      ),
      input_signature=tf_signature_to_obm_spec(input_signature),
      output_signature=tf_signature_to_obm_spec(output_signature),
  )


SAVED_MODEL_MIME_TYPE = 'application/x.tensorflow-saved-model'
SAVED_MODEL_VERSION = '1.0'


def tf_saved_model_as_obm_supplemental(subdir: str) -> obm.UnstructuredData:
  """An Orbax Model global supplemental pointing to a TF SavedModel (path).

  Args:
    subdir: the path to the TF SavedModel dir. This can be a path relative to
      the Orbax Model dir, such as 'tf_saved_model/', or an absolute path.

  Returns:
    An `obm.UnstructuredData` which can be used as an Orbax Model global
    supplemental.
  """
  return obm.manifest_pb2.UnstructuredData(
      file_system_location=obm.manifest_pb2.FileSystemLocation(
          string_path=subdir
      ),
      mime_type=SAVED_MODEL_MIME_TYPE,
      version=SAVED_MODEL_VERSION,
  )


def _make_dict_only_signature(
    names: Sequence[str], leaves: Sequence[tf.TensorSpec]
) -> _StrDict:
  """Creates a dict-only signature from names and leaves.

  Args:
    names: A sequence of names for the leaves.
    leaves: A sequence of tensor specs.

  Returns:
    A dict-only signature where keys are names and values are tensor specs.
  """
  # The TensorSpec values in `leaves` may have their `name` attribute
  # set. Some SavedModel loaders (e.g. TFRT) may use this `name`
  # instead of the key in the returned dict to construct the input signature. We
  # clear the `name` attribute to avoid that.
  return {
      k: tf.TensorSpec(
          shape=v.shape,
          dtype=v.dtype,
          name=None,
      )
      for k, v in zip(names, leaves)
  }


def _tree_to_dict(
    tree: TfSignature | None,
    names: Sequence[str] | None,
) -> _StrDict | None:
  """Converts a TF signature tree to a dictionary if names are provided.

  If `names` is None or `tree` is None, returns None. If `names` is provided,
  `tree` is flattened and a dictionary is created by mapping names to leaves.

  Args:
    tree: The TF signature tree.
    names: An optional sequence of names for leaves.

  Returns:
    A dictionary mapping names to leaves, or None.
  """
  if not names or tree is None:
    return None
  flat = jax_tree_util.tree_leaves(tree)
  return dict(zip(names, flat))


def _dict_to_tree(
    d: _StrDict | None,
    names: Sequence[str] | None,
    tree_def: jax_tree_util.PyTreeDef,
) -> TfSignature | None:
  """Converts a dictionary to a TF signature tree if names are provided.

  If `names` is None, `d` is returned unchanged. If `names` is provided,
  leaves are extracted from `d` in the order of `names` and unflattened into a
  tree using `tree_def`.

  Args:
    d: A dictionary mapping names to leaves.
    names: An optional sequence of names for leaves.
    tree_def: The PyTreeDef for unflattening.

  Returns:
    A TF signature tree.
  """
  if not names or not d:
    return None
  flat = tuple(d[name] for name in names)
  return jax_tree_util.tree_unflatten(tree_def, flat)


def _to_args_kwargs_pattern(
    tree: TfSignature,
) -> Tuple[Sequence[Any], Dict[str, Any]]:
  """Converts a TF signature tree to the '(args, kwargs)' pattern.

  Args:
    tree: a TF signature tree.

  Returns:
    A tuple `(args, kwargs)`, where `args` is a sequence of positional
    arguments, and `kwargs` is a dict of keyword arguments.

  Raises:
    ValueError: if the tree cannot be converted to the '(args, kwargs)' pattern.
  """
  if _is_args_kwargs_pattern(tree):
    return tree[0], tree[1]
  elif isinstance(tree, Sequence):
    return tree, {}
  elif isinstance(tree, dict):
    return (), tree
  else:
    raise ValueError(
        f"Can`t convert this tree to the '(args, kwargs)' pattern: {tree}"
    )


# The flattened form of a signature: a named tuple of (names, leaves, treedef).
class SignatureFlat(NamedTuple):
  """The flattened form of a signature.

  Attributes:
    names: A sequence of names for the leaves.
    leaves: A sequence of tensor specs.
    tree_def: The PyTreeDef for unflattening.
  """

  names: Sequence[str]
  leaves: Sequence[tf.TensorSpec]
  tree_def: jax_tree_util.PyTreeDef


def _flat_input_signature(
    fn: tf.types.experimental.ConcreteFunction,
) -> SignatureFlat:
  """Returns the flattened input signature of the given function."""
  leaves, tree_def = jax_tree_util.tree_flatten(fn.structured_input_signature)
  # The argument names in SavedModel's SignatureDef may not match the names in
  # the input signature due to internal name mangling, hence we're looking
  # it up in the FunctionDef.
  input_names = [arg.name for arg in fn.function_def.signature.input_arg]
  if len(input_names) < len(leaves):
    # There could be more arguments in the FunctionDef than in the input
    # signature, because it also contains the captured inputs appended
    # to the flattened list of the input arguments.
    raise ValueError(
        f'The number of input arguments in FunctionDef ({len(input_names)}) is'
        ' smaller than the number of leaves in the flattened input signature'
        f' ({len(leaves)})'
    )
  return SignatureFlat(input_names[: len(leaves)], leaves, tree_def)


def _output_name_for_key(key: Any) -> str:
  if isinstance(key, jax_tree_util.SequenceKey):
    return f'{_OUTPUT_NAME_PREFIX}_{key.idx}'
  elif isinstance(key, jax_tree_util.DictKey):
    # The order is stable as guaranteed by `jax.tree.flatten`.
    return f'{key.key}'
  elif isinstance(key, jax_tree_util.GetAttrKey):
    return f'{key.name}'
  raise ValueError(f'Invalid output key type: {key}')


def _output_name(path: Sequence[Any]) -> str:
  """Returns the output name based on its path in the output signature."""
  if not path:
    # Scalar return value (single tensor).
    return f'{_OUTPUT_NAME_PREFIX}_0'

  # Multiple levels of nesting is normally not suppported for
  # TF concrete function outputs. However, we already
  # support the case of nested sturctures in Orbax TF export,
  # so we will explicitly support nested structures here.
  return '.'.join(_output_name_for_key(k) for k in path)


def _output_names(
    fn: tf.types.experimental.ConcreteFunction,
) -> Sequence[str]:
  """Returns the flattened output signature of the given function."""
  leaves_with_path = jax_tree_util.tree_leaves_with_path(fn.structured_outputs)
  if not leaves_with_path:
    return []
  paths, _ = zip(*leaves_with_path)
  return [_output_name(path) for path in paths]


def get_output_signature(
    fn: tf.types.experimental.ConcreteFunction,
) -> TfSignature:
  """Returns the output signature of the TF function.

  Tensor names in the output signature match the output names of the TF function
  in the TF SavedModel.

  Args:
    fn: A concrete TF function.
  """
  output_names_iter = iter(list(_output_names(fn)))

  return jax_tree_util.tree_map(
      lambda t: tf.TensorSpec(
          shape=t.shape, dtype=t.dtype, name=next(output_names_iter)
      ),
      fn.structured_outputs,
  )


def to_keyword_only_fn(
    f: tf.types.experimental.ConcreteFunction,
) -> tf.types.experimental.ConcreteFunction:
  """Wraps a function into one whose inputs and outputs are keyword-only.

  Args:
    f: a TF concrete function.

  Returns:
    The wrapped function (also a TF concrete function).
  """
  input_names, input_leaves, input_def = _flat_input_signature(f)
  output_names = _output_names(f)

  if input_names is None and output_names is None:
    return f

  new_input_signature = _make_dict_only_signature(input_names, input_leaves)
  # Note that `new_input_signature`, `input_names` or `output_names`
  # may still be None here.

  @tf.function(
      autograph=False,
  )
  def new_f(**input_dict):
    args, kwargs = _to_args_kwargs_pattern(
        _dict_to_tree(
            input_dict,
            input_names,
            input_def,
        )
    )
    output = f(*args, **kwargs)
    new_output = _tree_to_dict(
        output,
        output_names,
    )
    return new_output

  return new_f.get_concrete_function(
      **new_input_signature,
  )


def save_tf_concrete_functions(
    path: str,
    concrete_functions: Mapping[str, tf.types.experimental.ConcreteFunction],
    trackable_resources: Any = None,
) -> None:
  """Saves TensorFlow (TF) concrete functions with names to a TF SavedModel.

  The TF SavedModel will have enough information to let one retrieve (and call)
  the concrete functions by their names.

  Args:
    path: the absolute path to save the TF SavedModel.
    concrete_functions: a mapping from names to concrete functions.
    trackable_resources: a nested structure (i.e. PyTree) of
      `tf.saved_model.experimental.TrackableResource`s that are used in
      `concrete_functions`. All TF resources the concrete functions use
      (directly or indirectly) must be present in this structure. Otherwise, an
      "untracked resource" error will be raised. If tf.Module is passed, it will
      be used to create the saved model.
  """
  # We are using saved_model.save(signatures=...)
  # (i.e. serving_signatures) to save concrete functions, but
  # serving_signatures only supports functions with keyword-only
  # arguments and outputs (where all arguments and outputs must be
  # tensors), so we need to wrap our concrete function into such a
  # conforming form, and save the information gap separately (in
  # tf_concrete_function_name_to_obm_function).
  concrete_functions = {
      k: to_keyword_only_fn(v) for k, v in concrete_functions.items()
  }

  tf_module = tf.Module()
  if isinstance(trackable_resources, tf.Module):
    # tf.Module may contain variables and other resources that cannot be
    # easily accessed piecemeal. The caller can pass the tf.Module directly
    # and it will be used to create the saved model; all nested resources
    # will be included.
    tf_module = trackable_resources
  elif trackable_resources is not None:
    tf_module.resources = trackable_resources

  tf.saved_model.save(tf_module, path, signatures=concrete_functions)


def create_supplemental_info_closure(
    concrete_functions: Mapping[str, tf.types.experimental.ConcreteFunction],
    trackable_resources: Any = None,
) -> Callable[[str], Mapping[str, obm.GlobalSupplemental]]:
  """Returns a closure that saves TF concrete functions as supplemental data."""

  def save_supplemental_info(
      path: str,
  ) -> Mapping[str, obm.GlobalSupplemental]:
    save_tf_concrete_functions(
        os.path.join(path, OBM_TF_SAVED_MODEL_SUB_DIR),
        concrete_functions,
        trackable_resources,
    )
    tf_global_supplemental = tf_saved_model_as_obm_supplemental(
        OBM_TF_SAVED_MODEL_SUB_DIR
    )
    return {
        TF_SAVED_MODEL_SUPPLEMENTAL_NAME: obm.GlobalSupplemental(
            tf_global_supplemental, None
        )
    }

  return save_supplemental_info
